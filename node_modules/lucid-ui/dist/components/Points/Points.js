'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _max2 = require('lodash/max');

var _max3 = _interopRequireDefault(_max2);

var _isDate2 = require('lodash/isDate');

var _isDate3 = _interopRequireDefault(_isDate2);

var _isFinite2 = require('lodash/isFinite');

var _isFinite3 = _interopRequireDefault(_isFinite2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('react-peek/prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _chartHelpers = require('../../util/chart-helpers');

var _d3Shape = require('d3-shape');

var d3Shape = _interopRequireWildcard(_d3Shape);

var _charts = require('../../constants/charts');

var chartConstants = _interopRequireWildcard(_charts);

var _Point = require('../Point/Point');

var _Point2 = _interopRequireDefault(_Point);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-Points');

var arrayOf = _propTypes2.default.arrayOf,
    func = _propTypes2.default.func,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    bool = _propTypes2.default.bool,
    string = _propTypes2.default.string;


function isValidSeries(series) {
	if ((0, _isArray3.default)(series)) {
		var last = (0, _last3.default)(series);
		return (0, _isFinite3.default)(last) || (0, _isDate3.default)(last);
	}

	return (0, _isFinite3.default)(series) || (0, _isDate3.default)(series);
}

var Points = (0, _componentTypes.createClass)({
	displayName: 'Points',

	statics: {},

	propTypes: {
		className: string,

		palette: arrayOf(string),

		colorMap: object,

		data: arrayOf(object).isRequired,

		xScale: func.isRequired,

		yScale: func.isRequired,

		xField: string,

		yFields: arrayOf(string),

		yStackedMax: number,

		colorOffset: number,

		hasStroke: bool,

		isStacked: bool
	},

	getDefaultProps: function getDefaultProps() {
		return {
			xField: 'x',
			yFields: ['y'],
			colorOffset: 0,
			hasStroke: true,
			isStacked: false,
			palette: chartConstants.PALETTE_6
		};
	},
	render: function render() {
		var _props = this.props,
		    className = _props.className,
		    data = _props.data,
		    palette = _props.palette,
		    colorMap = _props.colorMap,
		    colorOffset = _props.colorOffset,
		    xField = _props.xField,
		    hasStroke = _props.hasStroke,
		    xScale = _props.xScale,
		    yFields = _props.yFields,
		    yStackedMax = _props.yStackedMax,
		    isStacked = _props.isStacked,
		    yScaleOriginal = _props.yScale,
		    passThroughs = _objectWithoutProperties(_props, ['className', 'data', 'palette', 'colorMap', 'colorOffset', 'xField', 'hasStroke', 'xScale', 'yFields', 'yStackedMax', 'isStacked', 'yScale']);

		// Copy the original so we can mutate it


		var yScale = yScaleOriginal.copy();

		// If we are stacked, we need to calculate a new domain based on the sum of
		// the various series' y data. One row per series.
		var transformedData = isStacked ? d3Shape.stack().keys(yFields)(data) : (0, _chartHelpers.groupByFields)(data, yFields);

		// If we are stacked, we need to calculate a new domain based on the sum of
		// the various group's y data
		if (isStacked) {
			yScale.domain([yScale.domain()[0], yStackedMax || (0, _max3.default)((0, _flatten3.default)((0, _last3.default)(transformedData)))]);
		}

		return _react2.default.createElement(
			'g',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, Points), { className: cx(className, '&') }),
			(0, _map3.default)(transformedData, function (d, dIndex) {
				return (0, _map3.default)(d, function (series, seriesIndex) {
					return isValidSeries(series) ? _react2.default.createElement(_Point2.default, {
						key: '' + seriesIndex + dIndex,
						x: xScale(data[seriesIndex][xField]),
						y: yScale((0, _isArray3.default)(series) ? (0, _last3.default)(series) : series),
						hasStroke: hasStroke,
						kind: dIndex + colorOffset,
						color: (0, _get3.default)(colorMap, yFields[dIndex], palette[(dIndex + colorOffset) % palette.length])
					}) : null;
				});
			})
		);
	}
});

exports.default = Points;