'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _identity2 = require('lodash/identity');

var _identity3 = _interopRequireDefault(_identity2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('react-peek/prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _chartHelpers = require('../../util/chart-helpers');

var _d3Scale = require('d3-scale');

var d3Scale = _interopRequireWildcard(_d3Scale);

var _charts = require('../../constants/charts');

var chartConstants = _interopRequireWildcard(_charts);

var _Axis = require('../Axis/Axis');

var _Axis2 = _interopRequireDefault(_Axis);

var _AxisLabel = require('../AxisLabel/AxisLabel');

var _AxisLabel2 = _interopRequireDefault(_AxisLabel);

var _Bars = require('../Bars/Bars');

var _Bars2 = _interopRequireDefault(_Bars);

var _ContextMenu = require('../ContextMenu/ContextMenu');

var _ContextMenu2 = _interopRequireDefault(_ContextMenu);

var _Legend = require('../Legend/Legend');

var _Legend2 = _interopRequireDefault(_Legend);

var _EmptyStateWrapper = require('../EmptyStateWrapper/EmptyStateWrapper');

var _EmptyStateWrapper2 = _interopRequireDefault(_EmptyStateWrapper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-BarChart');

var arrayOf = _propTypes2.default.arrayOf,
    func = _propTypes2.default.func,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    shape = _propTypes2.default.shape,
    string = _propTypes2.default.string,
    array = _propTypes2.default.array,
    bool = _propTypes2.default.bool,
    oneOfType = _propTypes2.default.oneOfType,
    oneOf = _propTypes2.default.oneOf;


var BarChart = (0, _componentTypes.createClass)({
	displayName: 'BarChart',

	statics: {
		PADDING: 0.05,
		PADDING_GROUPED_OR_STACKED: 0.3,
		MARGIN: {
			top: 10,
			right: 20,
			bottom: 50,
			left: 80
		}
	},

	propTypes: {
		className: string,

		height: number,

		width: number,

		margin: shape({
			top: number,
			right: number,
			bottom: number,
			left: number
		}),

		data: arrayOf(object),
		legend: object,

		isLoading: bool,

		hasToolTips: bool,

		hasLegend: bool,

		palette: arrayOf(string),

		colorMap: object,

		xAxisField: string,
		xAxisTickCount: number,

		xAxisFormatter: func,

		xAxisTitle: string,

		xAxisTitleColor: oneOfType([number, string]),

		yAxisFields: array,

		yAxisMin: number,

		yAxisMax: number,

		yAxisFormatter: func,

		yAxisIsStacked: bool,

		yAxisTickCount: number,

		yAxisTitle: string,

		yAxisTitleColor: oneOfType([number, string]),

		yAxisTooltipFormatter: func,

		yAxisTooltipDataFormatter: func,

		renderTooltipBody: func,

		xAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal']),

		yAxisTextOrientation: oneOf(['vertical', 'horizontal', 'diagonal'])
	},

	getDefaultProps: function getDefaultProps() {
		return {
			height: 400,
			width: 1000,
			// duplicated because `statics` aren't available during getDefaultProps
			margin: {
				top: 10,
				right: 20,
				bottom: 50,
				left: 80
			},
			palette: chartConstants.PALETTE_6,
			hasToolTips: true,
			hasLegend: false,

			renderTooltipBody: null,

			xAxisField: 'x',
			xAxisTickCount: null,
			xAxisTitle: null,
			xAxisTitleColor: '#000',
			xAxisFormatter: _identity3.default,
			xAxisTextOrientation: 'horizontal',

			yAxisFields: ['y'],
			yAxisTickCount: null,
			yAxisIsStacked: false,
			yAxisMin: 0,
			yAxisTitle: null,
			yAxisTitleColor: '#000',
			yAxisTooltipFormatter: function yAxisTooltipFormatter(yField, yValueFormatted) {
				return yField + ': ' + yValueFormatted;
			},
			yAxisTextOrientation: 'horizontal'
		};
	},


	components: {
		/**
   * Renders wrapper when the data table has no data.
   */
		EmptyStateWrapper: _EmptyStateWrapper2.default
	},

	render: function render() {
		var _props = this.props,
		    className = _props.className,
		    height = _props.height,
		    width = _props.width,
		    marginOriginal = _props.margin,
		    data = _props.data,
		    legend = _props.legend,
		    isLoading = _props.isLoading,
		    hasToolTips = _props.hasToolTips,
		    hasLegend = _props.hasLegend,
		    palette = _props.palette,
		    colorMap = _props.colorMap,
		    renderTooltipBody = _props.renderTooltipBody,
		    xAxisField = _props.xAxisField,
		    xAxisFormatter = _props.xAxisFormatter,
		    xAxisTitle = _props.xAxisTitle,
		    xAxisTitleColor = _props.xAxisTitleColor,
		    xAxisTickCount = _props.xAxisTickCount,
		    xAxisTextOrientation = _props.xAxisTextOrientation,
		    yAxisFields = _props.yAxisFields,
		    yAxisFormatter = _props.yAxisFormatter,
		    yAxisTitle = _props.yAxisTitle,
		    yAxisTitleColor = _props.yAxisTitleColor,
		    yAxisIsStacked = _props.yAxisIsStacked,
		    yAxisTickCount = _props.yAxisTickCount,
		    yAxisMin = _props.yAxisMin,
		    yAxisTooltipFormatter = _props.yAxisTooltipFormatter,
		    yAxisTooltipDataFormatter = _props.yAxisTooltipDataFormatter,
		    _props$yAxisMax = _props.yAxisMax,
		    yAxisMax = _props$yAxisMax === undefined ? yAxisIsStacked ? (0, _chartHelpers.maxByFieldsStacked)(data, yAxisFields) : (0, _chartHelpers.maxByFields)(data, yAxisFields) : _props$yAxisMax,
		    yAxisTextOrientation = _props.yAxisTextOrientation,
		    passThroughs = _objectWithoutProperties(_props, ['className', 'height', 'width', 'margin', 'data', 'legend', 'isLoading', 'hasToolTips', 'hasLegend', 'palette', 'colorMap', 'renderTooltipBody', 'xAxisField', 'xAxisFormatter', 'xAxisTitle', 'xAxisTitleColor', 'xAxisTickCount', 'xAxisTextOrientation', 'yAxisFields', 'yAxisFormatter', 'yAxisTitle', 'yAxisTitleColor', 'yAxisIsStacked', 'yAxisTickCount', 'yAxisMin', 'yAxisTooltipFormatter', 'yAxisTooltipDataFormatter', 'yAxisMax', 'yAxisTextOrientation']);

		var margin = _extends({}, BarChart.MARGIN, marginOriginal);

		var svgClasses = cx(className, '&');

		var innerWidth = width - margin.left - margin.right;
		var innerHeight = height - margin.top - margin.bottom;

		// `paddingInner` determines the space between the bars or groups of bars
		var paddingInner = yAxisFields.length > 1 ? BarChart.PADDING_GROUPED_OR_STACKED : BarChart.PADDING;

		var xScale = d3Scale.scaleBand().domain((0, _map3.default)(data, xAxisField)).range([0, innerWidth]).paddingInner(paddingInner).paddingOuter(0.5);

		var yScale = d3Scale.scaleLinear().domain([yAxisMin, yAxisMax]).range([innerHeight, 0]);

		var xAxisFinalFormatter = xAxisFormatter || xScale.tickFormat();

		var yAxisFinalFormatter = yAxisFormatter || yScale.tickFormat();

		var yFinalFormatter = yAxisTooltipDataFormatter ? yAxisTooltipDataFormatter : yAxisFinalFormatter;

		if ((0, _isEmpty3.default)(data) || width < 1 || height < 1 || isLoading) {
			var emptyStateWrapper = (0, _componentTypes.getFirst)(this.props, BarChart.EmptyStateWrapper) || _react2.default.createElement(BarChart.EmptyStateWrapper, { Title: 'You have no data.' });

			return _react2.default.createElement(
				_EmptyStateWrapper2.default,
				_extends({}, emptyStateWrapper.props, {
					isEmpty: (0, _isEmpty3.default)(data),
					isLoading: isLoading
				}),
				emptyStateWrapper.props.children,
				_react2.default.createElement(
					'svg',
					_extends({}, (0, _componentTypes.omitProps)(passThroughs, BarChart), {
						className: svgClasses,
						width: width,
						height: height
					}),
					_react2.default.createElement(
						'g',
						{
							transform: 'translate(' + margin.left + ', ' + (innerHeight + margin.top) + ')'
						},
						_react2.default.createElement(_Axis2.default, { orient: 'bottom', scale: xScale, tickCount: xAxisTickCount })
					),
					_react2.default.createElement(
						'g',
						{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
						_react2.default.createElement(_Axis2.default, {
							orient: 'left',
							scale: yScale,
							tickFormat: yFinalFormatter,
							tickCount: yAxisTickCount
						})
					)
				)
			);
		}

		return _react2.default.createElement(
			'svg',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, BarChart), {
				className: svgClasses,
				width: width,
				height: height
			}),
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + (innerHeight + margin.top) + ')' },
				_react2.default.createElement(_Axis2.default, {
					orient: 'bottom',
					scale: xScale,
					outerTickSize: 0,
					tickFormat: xAxisFinalFormatter,
					tickCount: xAxisTickCount,
					textOrientation: xAxisTextOrientation
				}),
				hasLegend ? _react2.default.createElement(
					_ContextMenu2.default,
					{
						direction: 'down',
						alignment: 'center',
						directonOffset: (margin.bottom / 2 + _Legend2.default.HEIGHT / 2) * -1 /* should center the legend in the bottom margin */

					},
					_react2.default.createElement(
						_ContextMenu2.default.Target,
						{ elementType: 'g' },
						_react2.default.createElement('rect', {
							className: cx('&-invisible'),
							width: innerWidth,
							height: margin.bottom
						})
					),
					_react2.default.createElement(
						_ContextMenu2.default.FlyOut,
						{ className: cx('&-legend-container') },
						_react2.default.createElement(
							_Legend2.default,
							{ orient: 'horizontal' },
							(0, _map3.default)(yAxisFields, function (field, index) {
								return _react2.default.createElement(
									_Legend2.default.Item,
									{
										key: index,
										hasPoint: true,
										hasLine: false,
										color: (0, _get3.default)(colorMap, field, palette[index % palette.length]),
										pointKind: 1
									},
									(0, _get3.default)(legend, field, field)
								);
							})
						)
					)
				) : null
			),
			xAxisTitle ? _react2.default.createElement(
				'g',
				{
					transform: 'translate(' + margin.left + ', ' + (margin.top + innerHeight) + ')'
				},
				_react2.default.createElement(_AxisLabel2.default, {
					orient: 'bottom',
					width: innerWidth,
					height: margin.bottom,
					label: xAxisTitle,
					color: (0, _isString3.default)(xAxisTitleColor) ? xAxisTitleColor : palette[xAxisTitleColor % palette.length]
				})
			) : null,
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Axis2.default, _defineProperty({
					orient: 'left',
					textOrientation: 'horizontal',
					scale: yScale,
					tickFormat: yAxisFinalFormatter,
					tickCount: yAxisTickCount
				}, 'textOrientation', yAxisTextOrientation))
			),
			yAxisTitle ? _react2.default.createElement(
				'g',
				{ transform: 'translate(0, ' + margin.top + ')' },
				_react2.default.createElement(_AxisLabel2.default, {
					orient: 'left',
					width: margin.left,
					height: innerHeight,
					label: yAxisTitle,
					color: (0, _isString3.default)(yAxisTitleColor) ? yAxisTitleColor : palette[yAxisTitleColor % palette.length]
				})
			) : null,
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Bars2.default, {
					xField: xAxisField,
					xScale: xScale,
					xFormatter: xAxisFormatter,
					yFields: yAxisFields,
					yScale: yScale,
					yFormatter: yFinalFormatter,
					yStackedMax: yAxisMax,
					data: data,
					isStacked: yAxisIsStacked,
					yTooltipFormatter: yAxisTooltipFormatter,
					hasToolTips: hasToolTips,
					legend: legend,
					palette: palette,
					colorMap: colorMap,
					renderTooltipBody: renderTooltipBody
				})
			)
		);
	}
});

exports.default = BarChart;