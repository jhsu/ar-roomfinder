'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _noop2 = require('lodash/noop');

var _noop3 = _interopRequireDefault(_noop2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('react-peek/prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _TextField = require('./TextField.reducers');

var _TextField2 = _interopRequireDefault(_TextField);

var _keyCode = require('../../constants/key-code');

var KEYCODE = _interopRequireWildcard(_keyCode);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-TextField');

var bool = _propTypes2.default.bool,
    string = _propTypes2.default.string,
    func = _propTypes2.default.func,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    oneOfType = _propTypes2.default.oneOfType;


var TextField = (0, _componentTypes.createClass)({
	displayName: 'TextField',

	statics: {},

	reducers: _TextField2.default,

	propTypes: {
		style: object,

		isMultiLine: bool,

		isDisabled: bool,

		rows: number,

		className: string,

		onChange: func,

		onBlur: func,

		onChangeDebounced: func,

		onKeyDown: func,

		onSubmit: func,

		value: oneOfType([number, string]),

		debounceLevel: number,

		lazyLevel: number
	},

	getDefaultProps: function getDefaultProps() {
		return {
			style: null,
			isDisabled: false,
			isMultiLine: false,
			onBlur: _noop3.default,
			onChange: _noop3.default,
			onChangeDebounced: _noop3.default,
			onSubmit: _noop3.default,
			rows: 5,
			debounceLevel: 500,
			lazyLevel: 1000,
			value: ''
		};
	},
	getInitialState: function getInitialState() {
		return {
			value: this.props.value
		};
	},
	componentWillMount: function componentWillMount() {
		var _this = this;

		// Because we want the debounceLevel to be configurable, we can't put the
		// debounced handler directly on the react class, so we set it up right
		// before mount
		this._isMounted = true;
		this._handleChangeDebounced = (0, _debounce3.default)(function () {
			var _props;

			(_props = _this.props).onChangeDebounced.apply(_props, arguments);
		}, this.props.debounceLevel);

		this._releaseHold = (0, _debounce3.default)(function () {
			if (!_this._isMounted) {
				return;
			}
			_this.setState({ isHolding: false });
		}, this.props.lazyLevel);

		this._updateWhenReady = (0, _debounce3.default)(function (newValue) {
			if (!_this._isMounted) {
				return;
			}
			if (_this.state.isHolding) {
				_this._updateWhenReady(newValue);
			} else if (newValue !== _this.state.value) {
				_this.setState({ value: newValue });
			}
		}, this.props.lazyLevel);
	},
	componentWillUnmount: function componentWillUnmount() {
		this._isMounted = false;
	},
	componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		// Allow consumer to optionally control state
		if ((0, _has3.default)(nextProps, 'value')) {
			if (this.state.isHolding) {
				this._updateWhenReady(nextProps.value);
			} else {
				this.setState({ value: nextProps.value });
			}
		}
	},
	handleChange: function handleChange(event) {
		var _props2 = this.props,
		    onChange = _props2.onChange,
		    onChangeDebounced = _props2.onChangeDebounced;


		var value = (0, _get3.default)(event, 'target.value', '');

		this.setState({ value: value, isHolding: true });
		this._releaseHold();

		onChange(value, { event: event, props: this.props });

		// Also call the debounced handler in case the user wants debounced change
		// events.
		if (onChangeDebounced !== _noop3.default) {
			event.persist(); // https://facebook.github.io/react/docs/events.html#event-pooling
			this._handleChangeDebounced(value, { event: event, props: this.props });
		}
	},
	handleBlur: function handleBlur(event) {
		var _props3 = this.props,
		    onBlur = _props3.onBlur,
		    onChangeDebounced = _props3.onChangeDebounced;


		var value = (0, _get3.default)(event, 'target.value', '');

		if (onChangeDebounced !== _noop3.default) {
			this._handleChangeDebounced.flush();
		}
		onBlur(value, { event: event, props: this.props });
	},
	handleKeyDown: function handleKeyDown(event) {
		var props = this.props,
		    _props4 = this.props,
		    onSubmit = _props4.onSubmit,
		    onKeyDown = _props4.onKeyDown,
		    onChangeDebounced = _props4.onChangeDebounced;

		var value = (0, _get3.default)(event, 'target.value', '');

		// If the consumer passed an onKeyDown, we call it
		if (onKeyDown) {
			onKeyDown({ event: event, props: props });
		}

		if (event.keyCode === KEYCODE.Enter) {
			if (onChangeDebounced !== _noop3.default) {
				this._handleChangeDebounced.flush();
			}

			onSubmit(value, { event: event, props: this.props });
		}
	},
	focus: function focus() {
		/* istanbul ignore next */
		this.refs.nativeElement.focus();
	},
	render: function render() {
		var _this2 = this;

		var _props5 = this.props,
		    className = _props5.className,
		    isDisabled = _props5.isDisabled,
		    isMultiLine = _props5.isMultiLine,
		    rows = _props5.rows,
		    style = _props5.style,
		    passThroughs = _objectWithoutProperties(_props5, ['className', 'isDisabled', 'isMultiLine', 'rows', 'style']);

		var value = this.state.value;


		var finalProps = _extends({}, (0, _componentTypes.omitProps)(passThroughs, TextField, ['children']), {
			className: cx('&', {
				'&-is-disabled': isDisabled,
				'&-is-multi-line': isMultiLine,
				'&-is-single-line': !isMultiLine
			}, className),
			disabled: isDisabled,
			onChange: this.handleChange,
			onBlur: this.handleBlur,
			onKeyDown: this.handleKeyDown,
			style: style,
			rows: rows,
			value: value,
			ref: function ref(_ref) {
				return _this2.refs = { nativeElement: _ref };
			}
		});

		return isMultiLine ? _react2.default.createElement('textarea', finalProps) : _react2.default.createElement('input', _extends({ type: 'text' }, finalProps));
	}
});

exports.default = TextField;