'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.PureToolTip = undefined;

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _max2 = require('lodash/max');

var _max3 = _interopRequireDefault(_max2);

var _times2 = require('lodash/times');

var _times3 = _interopRequireDefault(_times2);

var _identity2 = require('lodash/identity');

var _identity3 = _interopRequireDefault(_identity2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _memoize2 = require('lodash/memoize');

var _memoize3 = _interopRequireDefault(_memoize2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('react-peek/prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _chartHelpers = require('../../util/chart-helpers');

var _componentTypes = require('../../util/component-types');

var _d3Scale = require('d3-scale');

var d3Scale = _interopRequireWildcard(_d3Scale);

var _charts = require('../../constants/charts');

var chartConstants = _interopRequireWildcard(_charts);

var _reactAddonsShallowCompare = require('react-addons-shallow-compare');

var _reactAddonsShallowCompare2 = _interopRequireDefault(_reactAddonsShallowCompare);

var _Bar = require('../Bar/Bar');

var _Bar2 = _interopRequireDefault(_Bar);

var _ToolTip = require('../ToolTip/ToolTip');

var _Legend = require('../Legend/Legend');

var _Legend2 = _interopRequireDefault(_Legend);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// memoizing to maintain referential equality across renders, for performance
// optimization with shallow comparison
var memoizedExtractFields = (0, _memoize3.default)(_chartHelpers.extractFields);
var memoizedStackByFields = (0, _memoize3.default)(_chartHelpers.stackByFields);

var cx = _styleHelpers.lucidClassNames.bind('&-Bars');

var arrayOf = _propTypes2.default.arrayOf,
    func = _propTypes2.default.func,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    bool = _propTypes2.default.bool,
    string = _propTypes2.default.string;


var Bars = (0, _componentTypes.createClass)({
	displayName: 'Bars',

	statics: {},

	propTypes: {
		className: string,

		data: arrayOf(object).isRequired,

		legend: object,

		hasToolTips: bool,

		palette: arrayOf(string),

		colorMap: object,

		xScale: func.isRequired,

		xField: string,

		xFormatter: func,

		yScale: func.isRequired,

		yFields: arrayOf(string),

		yFormatter: func,

		yStackedMax: number,

		yTooltipFormatter: func,

		isStacked: bool,

		colorOffset: number,

		renderTooltipBody: func
	},

	defaultTooltipFormatter: function defaultTooltipFormatter(dataPoint) {
		var _props = this.props,
		    colorMap = _props.colorMap,
		    colorOffset = _props.colorOffset,
		    isStacked = _props.isStacked,
		    legend = _props.legend,
		    palette = _props.palette,
		    yFields = _props.yFields,
		    yFormatter = _props.yFormatter,
		    yTooltipFormatter = _props.yTooltipFormatter;


		return _react2.default.createElement(
			_Legend2.default,
			{ hasBorders: false, isReversed: isStacked },
			(0, _map3.default)(yFields, function (field, fieldIndex) {
				return _react2.default.createElement(
					_Legend2.default.Item,
					{
						key: fieldIndex,
						hasPoint: true,
						pointKind: 1,
						color: (0, _get3.default)(colorMap, field, palette[(fieldIndex + colorOffset) % palette.length])
					},
					yTooltipFormatter((0, _get3.default)(legend, field, field), yFormatter(dataPoint[field]), dataPoint[field])
				);
			})
		);
	},
	handleMouseEnter: function handleMouseEnter(hoveringSeriesIndex) {
		this.setState({
			hoveringSeriesIndex: hoveringSeriesIndex
		});
	},
	handleMouseOut: function handleMouseOut() {
		this.setState({ hoveringSeriesIndex: null });
	},
	shouldComponentUpdate: function shouldComponentUpdate() {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _reactAddonsShallowCompare2.default.apply(undefined, [this].concat(_toConsumableArray(args)));
	},
	getDefaultProps: function getDefaultProps() {
		return {
			hasToolTips: true,
			xField: 'x',
			xFormatter: _identity3.default,
			yFields: ['y'],
			yFormatter: _identity3.default,
			yTooltipFormatter: function yTooltipFormatter(yField, yValueFormatted) {
				return yField + ': ' + yValueFormatted;
			},
			renderTooltipBody: null,
			isStacked: false,
			colorOffset: 0,
			palette: chartConstants.PALETTE_6
		};
	},
	getInitialState: function getInitialState() {
		return {
			hoveringSeriesIndex: null
		};
	},
	render: function render() {
		var _this = this;

		var _props2 = this.props,
		    className = _props2.className,
		    data = _props2.data,
		    hasToolTips = _props2.hasToolTips,
		    palette = _props2.palette,
		    colorMap = _props2.colorMap,
		    colorOffset = _props2.colorOffset,
		    xScale = _props2.xScale,
		    xField = _props2.xField,
		    xFormatter = _props2.xFormatter,
		    yScaleOriginal = _props2.yScale,
		    yFields = _props2.yFields,
		    yStackedMax = _props2.yStackedMax,
		    renderTooltipBody = _props2.renderTooltipBody,
		    isStacked = _props2.isStacked,
		    passThroughs = _objectWithoutProperties(_props2, ['className', 'data', 'hasToolTips', 'palette', 'colorMap', 'colorOffset', 'xScale', 'xField', 'xFormatter', 'yScale', 'yFields', 'yStackedMax', 'renderTooltipBody', 'isStacked']);

		var hoveringSeriesIndex = this.state.hoveringSeriesIndex;

		// This scale is used for grouped bars

		var innerXScale = d3Scale.scaleBand().domain((0, _times3.default)(yFields.length)).range([0, xScale.bandwidth()]).round(true);

		// Copy the original so we can mutate it
		var yScale = yScaleOriginal.copy();

		// If we are stacked, we need to calculate a new domain based on the sum of
		// the various series' y data. One row per series.
		var transformedData = isStacked ? memoizedStackByFields(data, yFields) : memoizedExtractFields(data, yFields);

		// If we are stacked, we need to calculate a new domain based on the sum of
		// the various group's y data
		if (isStacked) {
			yScale.domain([yScale.domain()[0], yStackedMax || (0, _max3.default)((0, _map3.default)(transformedData, function (x) {
				return (0, _last3.default)((0, _last3.default)(x));
			}))]);
		}

		return _react2.default.createElement(
			'g',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, Bars), { className: cx(className, '&') }),
			(0, _map3.default)(transformedData, function (series, seriesIndex) {
				return _react2.default.createElement(
					'g',
					{ key: seriesIndex },
					(0, _map3.default)(series, function (_ref, pointsIndex) {
						var _ref2 = _slicedToArray(_ref, 2),
						    start = _ref2[0],
						    end = _ref2[1];

						return _react2.default.createElement(_Bar2.default, {
							key: pointsIndex,
							x: isStacked ? xScale(data[seriesIndex][xField]) : innerXScale(pointsIndex) + xScale(data[seriesIndex][xField]),
							y: yScale(end),
							height: yScale(start) - yScale(end),
							width: isStacked ? xScale.bandwidth() : innerXScale.bandwidth(),
							color: (0, _get3.default)(colorMap, yFields[pointsIndex], palette[(pointsIndex + colorOffset) % palette.length])
						});
					}),
					_react2.default.createElement(PureToolTip, {
						isExpanded: hasToolTips && hoveringSeriesIndex === seriesIndex,
						height: isStacked ? yScale.range()[0] - yScale((0, _last3.default)(series)[1]) : yScale.range()[0] - yScale((0, _max3.default)((0, _flatten3.default)(series))),
						width: xScale.bandwidth(),
						x: xScale(data[seriesIndex][xField]),
						y: yScale((0, _max3.default)((0, _flatten3.default)(series))),
						series: series,
						seriesIndex: seriesIndex,
						onMouseEnter: _this.handleMouseEnter,
						onMouseOut: _this.handleMouseOut,
						xFormatter: xFormatter,
						xField: xField,
						renderBody: renderTooltipBody || _this.defaultTooltipFormatter,
						data: data
					})
				);
			})
		);
	}
});

var PureToolTip = exports.PureToolTip = (0, _componentTypes.createClass)({
	_isPrivate: true,
	propTypes: {
		data: arrayOf(object),
		height: number,
		isExpanded: bool,
		onMouseEnter: func,
		onMouseOut: func,
		renderBody: func,
		seriesIndex: number,
		width: number,
		x: number,
		xField: string,
		xFormatter: func,
		y: number
	},

	shouldComponentUpdate: function shouldComponentUpdate() {
		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		return _reactAddonsShallowCompare2.default.apply(undefined, [this].concat(_toConsumableArray(args)));
	},
	handleMouseEnter: function handleMouseEnter() {
		this.props.onMouseEnter(this.props.seriesIndex);
	},
	render: function render() {
		var _props3 = this.props,
		    isExpanded = _props3.isExpanded,
		    height = _props3.height,
		    width = _props3.width,
		    x = _props3.x,
		    y = _props3.y,
		    seriesIndex = _props3.seriesIndex,
		    onMouseOut = _props3.onMouseOut,
		    renderBody = _props3.renderBody,
		    data = _props3.data,
		    xFormatter = _props3.xFormatter,
		    xField = _props3.xField;


		return _react2.default.createElement(
			_ToolTip.ToolTipDumb,
			{ isExpanded: isExpanded, flyOutMaxWidth: 'none' },
			_react2.default.createElement(
				_ToolTip.ToolTipDumb.Target,
				{ elementType: 'g' },
				_react2.default.createElement('rect', {
					className: cx('&-tooltip-hover-zone'),
					height: height,
					width: width,
					x: x,
					y: y,
					onMouseEnter: this.handleMouseEnter,
					onMouseOut: onMouseOut
				})
			),
			_react2.default.createElement(
				_ToolTip.ToolTipDumb.Title,
				null,
				xFormatter(data[seriesIndex][xField])
			),
			_react2.default.createElement(
				_ToolTip.ToolTipDumb.Body,
				null,
				renderBody(data[seriesIndex])
			)
		);
	}
});

exports.default = Bars;