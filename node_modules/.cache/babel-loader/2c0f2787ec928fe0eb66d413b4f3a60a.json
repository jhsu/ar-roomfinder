{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _times2 = require('lodash/times');\n\nvar _times3 = _interopRequireDefault(_times2);\n\nvar _isNil2 = require('lodash/isNil');\n\nvar _isNil3 = _interopRequireDefault(_isNil2);\n\nvar _pick2 = require('lodash/pick');\n\nvar _pick3 = _interopRequireDefault(_pick2);\n\nvar _toArray2 = require('lodash/toArray');\n\nvar _toArray3 = _interopRequireDefault(_toArray2);\n\nvar _sum2 = require('lodash/sum');\n\nvar _sum3 = _interopRequireDefault(_sum2);\n\nvar _max2 = require('lodash/max');\n\nvar _max3 = _interopRequireDefault(_max2);\n\nvar _min2 = require('lodash/min');\n\nvar _min3 = _interopRequireDefault(_min2);\n\nvar _first2 = require('lodash/first');\n\nvar _first3 = _interopRequireDefault(_first2);\n\nvar _last2 = require('lodash/last');\n\nvar _last3 = _interopRequireDefault(_last2);\n\nvar _isEmpty2 = require('lodash/isEmpty');\n\nvar _isEmpty3 = _interopRequireDefault(_isEmpty2);\n\nvar _get2 = require('lodash/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _reduce2 = require('lodash/reduce');\n\nvar _reduce3 = _interopRequireDefault(_reduce2);\n\nvar _map2 = require('lodash/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _castArray2 = require('lodash/castArray');\n\nvar _castArray3 = _interopRequireDefault(_castArray2);\n\nexports.stackByFields = stackByFields;\nexports.extractFields = extractFields;\nexports.groupByFields = groupByFields;\nexports.byFields = byFields;\nexports.nearest = nearest;\nexports.minByFields = minByFields;\nexports.maxByFields = maxByFields;\nexports.maxByFieldsStacked = maxByFieldsStacked;\nexports.discreteTicks = discreteTicks;\nexports.transformFromCenter = transformFromCenter;\nexports.formatDate = formatDate;\n\nvar _d3TimeFormat = require('d3-time-format');\n\nvar d3TimeFormat = _interopRequireWildcard(_d3TimeFormat);\n\nvar _d3Time = require('d3-time');\n\nvar d3Time = _interopRequireWildcard(_d3Time);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * stackByFields\n *\n * D3's `stack` groups each series' data together but we sometimes we want the\n * stacked groups to remain grouped as in the original normalized data. This\n * function helps achieve that.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for row in the original `collection`\n */\n\n\nfunction stackByFields(collection, fields) {\n  var fieldsArray = (0, _castArray3.default)(fields);\n  return (0, _map3.default)(collection, function (d) {\n    return (0, _reduce3.default)(fieldsArray, function (acc, field) {\n      var dataPoint = (0, _get3.default)(d, field, 0);\n\n      if ((0, _isEmpty3.default)(acc)) {\n        return acc.concat([[0, dataPoint]]);\n      }\n\n      var last = (0, _last3.default)((0, _last3.default)(acc));\n      return acc.concat([[last, last + dataPoint]]);\n    }, []);\n  });\n}\n/**\n * extractFields\n *\n * This will return the data in a similar format to stackByFields but without\n * the stacking.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for each field\n */\n\n\nfunction extractFields(collection, fields) {\n  var fieldsArray = (0, _castArray3.default)(fields);\n  return (0, _map3.default)(collection, function (d) {\n    return (0, _map3.default)(fieldsArray, function (field) {\n      return [0, (0, _get3.default)(d, field, 0)];\n    });\n  });\n}\n/**\n * groupByFields\n *\n * This will return the data in a similar format to d3Shape.stack\n * but without the stacking of the data.\n *\n * @param {object[]} collection - normalized data you want to operate on\n * @param {string[]} fields - fields to pluck off for the y data\n * @return {array[]} - array of arrays, one for each field\n */\n\n\nfunction groupByFields(collection, fields) {\n  var fieldsArray = (0, _castArray3.default)(fields);\n  return (0, _map3.default)(fieldsArray, function (field) {\n    return (0, _map3.default)(collection, field);\n  });\n}\n/**\n * byFields\n *\n * Takes a collection of data and returns an array of all the fields off that\n * collection.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {array}\n */\n\n\nfunction byFields(collection, fields) {\n  var fieldArray = (0, _castArray3.default)(fields);\n  return (0, _reduce3.default)(fieldArray, function (acc, field) {\n    return acc.concat((0, _map3.default)(collection, field));\n  }, []);\n}\n/**\n * nearest\n *\n * Divide and conquer algorithm that helps find the nearest element to `value`\n * in `nums`\n *\n * @param {number[]} nums - sorted array of numbers to search through\n * @param {number} value - value you're trying to locate the nearest array element for\n * @return {number} - the nearest array element to the value\n */\n\n\nfunction nearest(nums, value) {\n  if (nums.length < 2) {\n    return (0, _first3.default)(nums);\n  }\n\n  if (nums.length === 2) {\n    return value > (nums[0] + nums[1]) / 2 ? nums[1] : nums[0];\n  }\n\n  var mid = nums.length >>> 1;\n  return nums[mid] > value ? nearest(nums.slice(0, mid + 1), value) : nearest(nums.slice(mid), value);\n}\n/**\n * minByFields\n *\n * Returns the minimum element from a collection by a set of fields.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\n\n\nfunction minByFields(collection, fields) {\n  return (0, _min3.default)(byFields(collection, fields));\n}\n/**\n * maxByFields\n *\n * Returns the maximum element from a collection by a set of fields.\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\n\n\nfunction maxByFields(collection, fields) {\n  return (0, _max3.default)(byFields(collection, fields));\n}\n/**\n * maxByFieldsStacked\n *\n * Returns the max sum of a set of fields from a collection\n *\n * @param {object[]} collection\n * @param {string[]} fields\n * @return {any}\n */\n\n\nfunction maxByFieldsStacked(collection, fields) {\n  var fieldArray = (0, _castArray3.default)(fields);\n  var sums = (0, _reduce3.default)(collection, function (acc, item) {\n    return acc.concat((0, _sum3.default)((0, _toArray3.default)((0, _pick3.default)(item, fieldArray))));\n  }, []);\n  return (0, _max3.default)(sums);\n}\n/**\n * discreteTicks\n *\n * Returns `count` evenly spaced, representative values from the `array`.\n *\n * @param {array} array\n * @param {number} size - should be greater than 1\n * @return {array}\n */\n\n\nfunction discreteTicks(array, count) {\n  if (!array || (0, _isNil3.default)(count) || array.length <= count) {\n    return array;\n  }\n\n  var step = (array.length - 1) / Math.max(1, count - 1);\n  return (0, _reduce3.default)((0, _times3.default)(count), function (acc, n) {\n    return acc.concat(array[Math.round(n * step)]);\n  }, []);\n}\n/**\n * transformFromCenter\n *\n * Scaling paths from their center is tricky. This function\n * helps do that be generating a translate/scale transform\n * string with the correct numbers.\n *\n * @param {number} x - the x data point where you want the path to be centered at\n * @param {number} y - the y data point where you want the path to be centered at\n * @param {number} xCenter - the x coordinate of the center of the path you're trying to transform\n * @param {number} yCenter - the x coordinate of the center of the path you're trying to transform\n * @param {number} scale - number to scale to, 2 would be 2x bigger\n * @return {string} - transform string\n */\n\n\nfunction transformFromCenter(x, y, xCenter, yCenter, scale) {\n  return 'translate(' + ((1 - scale) * xCenter + (x - xCenter)) + ', ' + ((1 - scale) * yCenter + (y - yCenter)) + ') scale(' + scale + ')';\n}\n\nvar FORMAT_MILLISECOND = d3TimeFormat.timeFormat('.%L');\nvar FORMAT_SECOND = d3TimeFormat.timeFormat(':%S');\nvar FORMAT_MINUTE = d3TimeFormat.timeFormat('%I:%M');\nvar FORMAT_HOUR = d3TimeFormat.timeFormat('%I %p');\nvar FORMAT_DAY = d3TimeFormat.timeFormat('%a %d');\nvar FORMAT_WEEK = d3TimeFormat.timeFormat('%b %d');\nvar FORMAT_MONTH = d3TimeFormat.timeFormat('%b');\nvar FORMAT_YEAR = d3TimeFormat.timeFormat('%Y');\n/**\n * formatDate\n *\n * This function was written to be used for tick formatting with d3 time\n * scales.\n *\n * @param {date} date - input date\n * @return {string} - formatted date\n */\n\nfunction formatDate(date) {\n  return (d3Time.timeSecond(date) < date ? FORMAT_MILLISECOND : d3Time.timeMinute(date) < date ? FORMAT_SECOND : d3Time.timeHour(date) < date ? FORMAT_MINUTE : d3Time.timeDay(date) < date ? FORMAT_HOUR : d3Time.timeMonth(date) < date ? d3Time.timeWeek(date) < date ? FORMAT_DAY : FORMAT_WEEK : d3Time.timeYear(date) < date ? FORMAT_MONTH : FORMAT_YEAR)(date);\n}","map":null,"metadata":{},"sourceType":"script"}